#!/usr/bin/env python3
"""
Export DuckDB schema to documentation files.

Usage:
    uv run python scripts/export_schema.py

Outputs:
    - docs/schema.sql: DDL statements
    - docs/database-schema.md: Human-readable documentation
"""

import argparse
import sys
from pathlib import Path
from typing import Any

import duckdb


def get_table_ddl(conn: duckdb.DuckDBPyConnection, table_name: str) -> str:
    """Get CREATE TABLE statement for a table."""
    # DuckDB doesn't have SHOW CREATE TABLE, so we reconstruct from information_schema
    result = conn.execute(
        """
        SELECT
            column_name,
            data_type,
            is_nullable,
            column_default
        FROM information_schema.columns
        WHERE table_schema = 'main' AND table_name = ?
        ORDER BY ordinal_position
        """,
        [table_name],
    ).fetchall()

    if not result:
        return f"-- No schema found for {table_name}\n"

    ddl = f"CREATE TABLE {table_name} (\n"
    columns = []
    for col_name, data_type, is_nullable, col_default in result:
        col_def = f"    {col_name} {data_type}"
        if is_nullable == "NO":
            col_def += " NOT NULL"
        if col_default:
            col_def += f" DEFAULT {col_default}"
        columns.append(col_def)

    ddl += ",\n".join(columns)
    ddl += "\n);\n"

    return ddl


def get_table_info(conn: duckdb.DuckDBPyConnection, table_name: str) -> dict[str, Any]:
    """Get comprehensive information about a table."""
    # Get column info
    columns = conn.execute(
        """
        SELECT
            column_name,
            data_type,
            is_nullable,
            column_default
        FROM information_schema.columns
        WHERE table_schema = 'main' AND table_name = ?
        ORDER BY ordinal_position
        """,
        [table_name],
    ).fetchall()

    # Get row count
    row_count = conn.execute(f"SELECT COUNT(*) FROM {table_name}").fetchone()[0]

    # Get constraints (DuckDB has limited constraint introspection)
    # We can check for primary keys via duckdb_constraints view if it exists
    try:
        constraints = conn.execute(
            """
            SELECT constraint_type, constraint_name
            FROM information_schema.table_constraints
            WHERE table_schema = 'main' AND table_name = ?
            """,
            [table_name],
        ).fetchall()
    except Exception:
        constraints = []

    return {
        "name": table_name,
        "columns": columns,
        "row_count": row_count,
        "constraints": constraints,
    }


def generate_sql_ddl(conn: duckdb.DuckDBPyConnection, output_path: Path) -> None:
    """Generate SQL DDL file with CREATE TABLE statements."""
    tables = conn.execute(
        """
        SELECT table_name
        FROM information_schema.tables
        WHERE table_schema = 'main'
        ORDER BY table_name
        """
    ).fetchall()

    with output_path.open("w") as f:
        f.write("-- DuckDB Schema Export\n")
        f.write(
            "-- Generated by scripts/export_schema.py\n"
        )
        f.write("-- DO NOT EDIT MANUALLY - This file is auto-generated\n\n")

        for (table_name,) in tables:
            f.write(f"-- Table: {table_name}\n")
            f.write(get_table_ddl(conn, table_name))
            f.write("\n")

    print(f"✓ Generated SQL DDL: {output_path}")


def generate_markdown_docs(conn: duckdb.DuckDBPyConnection, output_path: Path) -> None:
    """Generate human-readable markdown documentation."""
    tables = conn.execute(
        """
        SELECT table_name
        FROM information_schema.tables
        WHERE table_schema = 'main'
        ORDER BY table_name
        """
    ).fetchall()

    with output_path.open("w") as f:
        f.write("# Database Schema\n\n")
        f.write("> **Auto-generated** by `scripts/export_schema.py`\n")
        f.write("> Last updated: Run script to regenerate\n\n")

        f.write("## Table of Contents\n\n")
        for (table_name,) in tables:
            f.write(f"- [{table_name}](#{table_name})\n")
        f.write("\n---\n\n")

        # Generate detailed docs for each table
        for (table_name,) in tables:
            info = get_table_info(conn, table_name)
            f.write(f"## {table_name}\n\n")

            # Add placeholder for human description
            f.write(f"**Purpose:** *TODO: Add description*\n\n")

            # Row count
            f.write(f"**Current rows:** {info['row_count']:,}\n\n")

            # Columns table
            f.write("### Columns\n\n")
            f.write("| Column | Type | Nullable | Default | Description |\n")
            f.write("|--------|------|----------|---------|-------------|\n")

            for col_name, data_type, is_nullable, col_default in info["columns"]:
                nullable = "✓" if is_nullable == "YES" else ""
                default = col_default if col_default else ""
                f.write(
                    f"| `{col_name}` | {data_type} | {nullable} | {default} | *TODO* |\n"
                )

            f.write("\n")

            # Constraints
            if info["constraints"]:
                f.write("### Constraints\n\n")
                for constraint_type, constraint_name in info["constraints"]:
                    f.write(f"- {constraint_type}: `{constraint_name}`\n")
                f.write("\n")

            # Relationships placeholder
            f.write("### Relationships\n\n")
            f.write("*TODO: Document foreign keys and relationships*\n\n")

            # Related code placeholder
            f.write("### Related Code\n\n")
            f.write("*TODO: Link to parser/query code*\n\n")

            f.write("---\n\n")

    print(f"✓ Generated Markdown docs: {output_path}")


def main() -> None:
    parser = argparse.ArgumentParser(description="Export DuckDB schema to documentation")
    parser.add_argument(
        "--database",
        default="data/tournament_data.duckdb",
        help="Path to DuckDB database",
    )
    parser.add_argument(
        "--sql-output",
        default="docs/schema.sql",
        help="Output path for SQL DDL",
    )
    parser.add_argument(
        "--markdown-output",
        default="docs/database-schema.md",
        help="Output path for Markdown documentation",
    )
    args = parser.parse_args()

    db_path = Path(args.database)
    if not db_path.exists():
        print(f"Error: Database not found: {db_path}", file=sys.stderr)
        sys.exit(1)

    print(f"Exporting schema from {db_path}...")

    conn = duckdb.connect(str(db_path), read_only=True)

    # Generate both formats
    generate_sql_ddl(conn, Path(args.sql_output))
    generate_markdown_docs(conn, Path(args.markdown_output))

    conn.close()

    print("\n✓ Schema export complete!")
    print("\nNext steps:")
    print("1. Review docs/database-schema.md")
    print("2. Fill in TODO descriptions and relationships")
    print("3. Add to git: git add docs/schema.sql docs/database-schema.md")


if __name__ == "__main__":
    main()
