<!DOCTYPE html>
<html>
<head>
    <title>Hex Tiling Test - Masked Sprites</title>
    <script src="https://pixijs.download/v7.3.2/pixi.min.js"></script>
    <style>
        body { margin: 0; background: #1a1a2e; overflow: hidden; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-family: monospace;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        .slider-row { margin: 5px 0; }
        .slider-row label { display: inline-block; width: 120px; }
        .slider-row input { width: 100px; }
        .slider-row span { display: inline-block; width: 50px; }
    </style>
</head>
<body>
    <div id="info">
        <strong>Masked Hex Tiling</strong><br>
        Clips sprites to hex boundaries to hide shadows<br>
        <span id="status">Loading...</span>
    </div>
    <div id="controls">
        <div class="slider-row">
            <label>Horiz Spacing:</label>
            <input type="range" id="hSpacing" min="150" max="220" value="211" oninput="updateSpacing()">
            <span id="hSpacingVal">211</span>
        </div>
        <div class="slider-row">
            <label>Vert Spacing:</label>
            <input type="range" id="vSpacing" min="100" max="180" value="136" oninput="updateSpacing()">
            <span id="vSpacingVal">136</span>
        </div>
        <div class="slider-row">
            <label>Odd Offset X:</label>
            <input type="range" id="offsetX" min="0" max="150" value="105" oninput="updateSpacing()">
            <span id="offsetXVal">105</span>
        </div>
        <div class="slider-row">
            <label>Hex Radius:</label>
            <input type="range" id="hexRadius" min="80" max="120" value="105" oninput="updateSpacing()">
            <span id="hexRadiusVal">105</span>
        </div>
        <button onclick="copyConfig()">Copy Config</button>
    </div>
    <canvas id="canvas"></canvas>

    <script>
        let app, mapContainer;
        let currentConfig = {
            horizontalSpacing: 211,
            verticalSpacing: 136,
            oddRowOffsetX: 105,
            hexRadius: 105,  // For mask sizing
        };

        const TERRAIN_TYPES = [
            'TERRAIN_TEMPERATE', 'TERRAIN_ARID', 'TERRAIN_LUSH',
            'TERRAIN_SAND', 'TERRAIN_WATER', 'TERRAIN_MARSH'
        ];

        let textures = {};
        let hexContainers = [];

        async function init() {
            app = new PIXI.Application({
                view: document.getElementById('canvas'),
                width: window.innerWidth,
                height: window.innerHeight,
                backgroundColor: 0x1a1a2e,
            });

            mapContainer = new PIXI.Container();
            app.stage.addChild(mapContainer);

            // Load textures
            for (const terrain of TERRAIN_TYPES) {
                try {
                    textures[terrain] = await PIXI.Assets.load(`/assets/sprites/terrains/${terrain}.png`);
                } catch(e) {
                    console.warn(`Failed to load ${terrain}`);
                }
            }

            // Create grid
            createHexGrid();
            setupControls();

            document.getElementById('status').textContent = 'Loaded! Drag to pan, scroll to zoom.';
        }

        function createHexMask(radius) {
            // Create a pointy-top hexagon mask
            const mask = new PIXI.Graphics();
            mask.beginFill(0xffffff);

            // Pointy-top hex vertices
            const points = [];
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i - Math.PI / 2;  // Start from top
                points.push(radius * Math.cos(angle));
                points.push(radius * Math.sin(angle));
            }
            mask.drawPolygon(points);
            mask.endFill();

            return mask;
        }

        function createHexGrid() {
            mapContainer.removeChildren();
            hexContainers = [];

            const gridWidth = 12;
            const gridHeight = 10;

            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const terrainIndex = (x + y * 3) % TERRAIN_TYPES.length;
                    const terrain = TERRAIN_TYPES[terrainIndex];
                    const texture = textures[terrain];

                    if (!texture) continue;

                    // Create a container for the masked sprite
                    const container = new PIXI.Container();

                    // Create the sprite
                    const sprite = new PIXI.Sprite(texture);
                    sprite.anchor.set(0.5);  // Center anchor for proper masking

                    // Create hex mask
                    const mask = createHexMask(currentConfig.hexRadius);

                    // Add to container
                    container.addChild(sprite);
                    container.addChild(mask);
                    sprite.mask = mask;

                    // Calculate position (pointy-top offset)
                    const pixelX = x * currentConfig.horizontalSpacing + (y % 2) * currentConfig.oddRowOffsetX;
                    const pixelY = y * currentConfig.verticalSpacing;

                    container.x = pixelX;
                    container.y = pixelY;

                    mapContainer.addChild(container);
                    hexContainers.push({ container, sprite, mask, x, y });
                }
            }

            mapContainer.x = 150;
            mapContainer.y = 100;
        }

        function updateSpacing() {
            currentConfig.horizontalSpacing = parseFloat(document.getElementById('hSpacing').value);
            currentConfig.verticalSpacing = parseFloat(document.getElementById('vSpacing').value);
            currentConfig.oddRowOffsetX = parseFloat(document.getElementById('offsetX').value);
            currentConfig.hexRadius = parseFloat(document.getElementById('hexRadius').value);

            document.getElementById('hSpacingVal').textContent = currentConfig.horizontalSpacing;
            document.getElementById('vSpacingVal').textContent = currentConfig.verticalSpacing;
            document.getElementById('offsetXVal').textContent = currentConfig.oddRowOffsetX;
            document.getElementById('hexRadiusVal').textContent = currentConfig.hexRadius;

            // Update positions and masks
            for (const item of hexContainers) {
                const pixelX = item.x * currentConfig.horizontalSpacing + (item.y % 2) * currentConfig.oddRowOffsetX;
                const pixelY = item.y * currentConfig.verticalSpacing;
                item.container.x = pixelX;
                item.container.y = pixelY;

                // Update mask size
                item.mask.clear();
                item.mask.beginFill(0xffffff);
                const points = [];
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i - Math.PI / 2;
                    points.push(currentConfig.hexRadius * Math.cos(angle));
                    points.push(currentConfig.hexRadius * Math.sin(angle));
                }
                item.mask.drawPolygon(points);
                item.mask.endFill();
            }
        }

        function copyConfig() {
            const config = `horizontalSpacing: ${currentConfig.horizontalSpacing},
verticalSpacing: ${currentConfig.verticalSpacing},
oddRowOffsetX: ${currentConfig.oddRowOffsetX},
hexRadius: ${currentConfig.hexRadius}`;
            navigator.clipboard.writeText(config);
            alert('Config copied!');
        }

        function setupControls() {
            let isDragging = false;
            let lastPos = { x: 0, y: 0 };

            app.view.addEventListener('mousedown', (e) => {
                isDragging = true;
                lastPos = { x: e.clientX, y: e.clientY };
            });

            window.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    mapContainer.x += e.clientX - lastPos.x;
                    mapContainer.y += e.clientY - lastPos.y;
                    lastPos = { x: e.clientX, y: e.clientY };
                }
            });

            window.addEventListener('mouseup', () => { isDragging = false; });

            app.view.addEventListener('wheel', (e) => {
                e.preventDefault();
                const scale = mapContainer.scale.x * (e.deltaY > 0 ? 0.9 : 1.1);
                mapContainer.scale.set(Math.max(0.1, Math.min(3, scale)));
            });
        }

        init();
    </script>
</body>
</html>
