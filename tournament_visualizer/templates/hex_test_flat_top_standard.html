<!DOCTYPE html>
<html>
<head>
    <title>Hex Tiling Test - flat_top_standard</title>
    <script src="https://pixijs.download/v7.3.2/pixi.min.js"></script>
    <style>
        body { margin: 0; background: #1a1a2e; overflow: hidden; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-family: monospace;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        .slider-row { margin: 5px 0; }
        .slider-row label { display: inline-block; width: 120px; }
        .slider-row input { width: 100px; }
        .slider-row span { display: inline-block; width: 50px; }
    </style>
</head>
<body>
    <div id="info">
        <strong>flat_top_standard</strong><br>
        Standard flat-top hex math<br>
        <span id="status">Loading...</span>
    </div>
    <div id="controls">
        <div class="slider-row">
            <label>Horiz Spacing:</label>
            <input type="range" id="hSpacing" min="150" max="220" value="158" oninput="updateSpacing()">
            <span id="hSpacingVal">158</span>
        </div>
        <div class="slider-row">
            <label>Vert Spacing:</label>
            <input type="range" id="vSpacing" min="100" max="200" value="181" oninput="updateSpacing()">
            <span id="vSpacingVal">181</span>
        </div>
        <div class="slider-row">
            <label>Odd Offset X:</label>
            <input type="range" id="offsetX" min="0" max="150" value="0" oninput="updateSpacing()">
            <span id="offsetXVal">0</span>
        </div>
        <div class="slider-row">
            <label>Odd Offset Y:</label>
            <input type="range" id="offsetY" min="0" max="150" value="90.5" oninput="updateSpacing()">
            <span id="offsetYVal">90.5</span>
        </div>
        <button onclick="copyConfig()">Copy Config</button>
    </div>
    <canvas id="canvas"></canvas>

    <script>
        const CONFIG = {
            hexWidth: 211,
            hexHeight: 181,
            horizontalSpacing: 158,
            verticalSpacing: 181,
            oddRowOffsetX: 0,
            oddRowOffsetY: 90.5,
            offsetOddRows: false,
        };

        let app, mapContainer, sprites = [];
        let currentConfig = {...CONFIG};

        const TERRAIN_TYPES = [
            'TERRAIN_TEMPERATE', 'TERRAIN_ARID', 'TERRAIN_LUSH',
            'TERRAIN_SAND', 'TERRAIN_WATER', 'TERRAIN_MARSH'
        ];

        async function init() {
            app = new PIXI.Application({
                view: document.getElementById('canvas'),
                width: window.innerWidth,
                height: window.innerHeight,
                backgroundColor: 0x1a1a2e,
            });

            mapContainer = new PIXI.Container();
            app.stage.addChild(mapContainer);

            // Load textures
            const textures = {};
            for (const terrain of TERRAIN_TYPES) {
                try {
                    textures[terrain] = await PIXI.Assets.load(`/assets/sprites/terrains/${terrain}.png`);
                } catch(e) {
                    console.warn(`Failed to load ${terrain}`);
                }
            }

            // Create grid of hexes
            createHexGrid(textures);

            // Enable pan/zoom
            setupControls();

            document.getElementById('status').textContent = 'Loaded! Drag to pan, scroll to zoom.';
        }

        function createHexGrid(textures) {
            // Clear existing
            mapContainer.removeChildren();
            sprites = [];

            const gridWidth = 15;
            const gridHeight = 12;

            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    // Pick terrain based on position for variety
                    const terrainIndex = (x + y * 3) % TERRAIN_TYPES.length;
                    const terrain = TERRAIN_TYPES[terrainIndex];
                    const texture = textures[terrain];

                    if (!texture) continue;

                    const sprite = new PIXI.Sprite(texture);

                    // Calculate position
                    let pixelX, pixelY;
                    if (currentConfig.offsetOddRows) {
                        // Pointy-top: odd rows offset horizontally
                        pixelX = x * currentConfig.horizontalSpacing + (y % 2) * currentConfig.oddRowOffsetX;
                        pixelY = y * currentConfig.verticalSpacing;
                    } else {
                        // Flat-top: odd columns offset vertically
                        pixelX = x * currentConfig.horizontalSpacing;
                        pixelY = y * currentConfig.verticalSpacing + (x % 2) * currentConfig.oddRowOffsetY;
                    }

                    sprite.x = pixelX;
                    sprite.y = pixelY;

                    mapContainer.addChild(sprite);
                    sprites.push(sprite);
                }
            }

            // Center the map
            mapContainer.x = 100;
            mapContainer.y = 100;
        }

        function updateSpacing() {
            currentConfig.horizontalSpacing = parseFloat(document.getElementById('hSpacing').value);
            currentConfig.verticalSpacing = parseFloat(document.getElementById('vSpacing').value);
            currentConfig.oddRowOffsetX = parseFloat(document.getElementById('offsetX').value);
            currentConfig.oddRowOffsetY = parseFloat(document.getElementById('offsetY').value);

            document.getElementById('hSpacingVal').textContent = currentConfig.horizontalSpacing;
            document.getElementById('vSpacingVal').textContent = currentConfig.verticalSpacing;
            document.getElementById('offsetXVal').textContent = currentConfig.oddRowOffsetX;
            document.getElementById('offsetYVal').textContent = currentConfig.oddRowOffsetY;

            // Update sprite positions
            let i = 0;
            const gridWidth = 15;
            const gridHeight = 12;

            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    if (i >= sprites.length) break;

                    let pixelX, pixelY;
                    if (currentConfig.offsetOddRows) {
                        pixelX = x * currentConfig.horizontalSpacing + (y % 2) * currentConfig.oddRowOffsetX;
                        pixelY = y * currentConfig.verticalSpacing;
                    } else {
                        pixelX = x * currentConfig.horizontalSpacing;
                        pixelY = y * currentConfig.verticalSpacing + (x % 2) * currentConfig.oddRowOffsetY;
                    }

                    sprites[i].x = pixelX;
                    sprites[i].y = pixelY;
                    i++;
                }
            }
        }

        function copyConfig() {
            const config = `horizontalSpacing: ${currentConfig.horizontalSpacing},
verticalSpacing: ${currentConfig.verticalSpacing},
oddRowOffsetX: ${currentConfig.oddRowOffsetX},
oddRowOffsetY: ${currentConfig.oddRowOffsetY}`;
            navigator.clipboard.writeText(config);
            alert('Config copied to clipboard!');
        }

        function setupControls() {
            let isDragging = false;
            let lastPos = { x: 0, y: 0 };

            app.view.addEventListener('mousedown', (e) => {
                isDragging = true;
                lastPos = { x: e.clientX, y: e.clientY };
            });

            window.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    mapContainer.x += e.clientX - lastPos.x;
                    mapContainer.y += e.clientY - lastPos.y;
                    lastPos = { x: e.clientX, y: e.clientY };
                }
            });

            window.addEventListener('mouseup', () => { isDragging = false; });

            app.view.addEventListener('wheel', (e) => {
                e.preventDefault();
                const scale = mapContainer.scale.x * (e.deltaY > 0 ? 0.9 : 1.1);
                mapContainer.scale.set(Math.max(0.1, Math.min(3, scale)));
            });
        }

        init();
    </script>
</body>
</html>